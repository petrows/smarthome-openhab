import org.openhab.core.model.script.ScriptServiceUtil

// === MISC RULES ==========================================

rule "Heating safe switch"
when
	Time cron "0 00 01,02,03,04 ? * *"
then
	logWarn("heating", "Set safe off")
	g_hz_all.sendCommand(cfgHeatingTempOff.state as Number)
end

// === TIME RULES ==========================================

rule "Heating NIGHT"
when
	Time cron "0 00 22 ? * *"
then
	logWarn("heating", "Set NIGHT")

	hz_temp_auto.sendCommand(cfgHeatingTempNight.state as Number)
end

rule "Heating MORNING"
when
	Time cron "0 00 5 ? * *"
then
	logWarn("heating", "Set MORNING")

	hz_temp_auto.sendCommand(cfgHeatingTempHeat.state as Number)
end

rule "Heating DAY"
when
	Time cron "0 00 7 ? * *"
then
	logWarn("heating", "Set DAY")

	hz_temp_auto.sendCommand(cfgHeatingTempDay.state as Number)
end

rule "Heating EVENING"
when
	Time cron "0 00 18 ? * *"
then
	logWarn("heating", "Set EVENING")

	hz_temp_auto.sendCommand(cfgHeatingTempHeat.state as Number)
end

rule "Heating TEST"
when
	Item hz_temp_auto changed
then
	g_hz_auto.members.forEach [s |
        logWarn("heating", "Item: " + s.name + " = " + s.state)
        val room_name = transform("REGEX", "hz_(.*)_set", s.name.toString)
        logWarn("heating", "Item room: " + room_name)

        val room_heating_enabled = true
        val room_sensors_enabled = true

        // Check that we have master-switch for this room
        try {
            val SwitchItem room_switch = ScriptServiceUtil.getItemRegistry?.getItem(room_name + "_heating_enabled") as SwitchItem
            // If we have
            // logWarn("heating", "Item room sw: " + room_switch)
            if (room_switch.state == OFF) {
                logWarn("heating", "Room " + room_name + " switch " + room_switch.name + " is " + room_switch.state)
                room_heating_enabled = false
            }
        } catch(Throwable t) {
            // Nothing
        }
        // Check that we have window-sensors for this room
        try {
            val GroupItem room_sensors = ScriptServiceUtil.getItemRegistry?.getItem(room_name + "_windows") as GroupItem
            room_sensors.members.forEach [sensor |
                if (room_sensors_enabled) {
                    if (sensor.state == OFF || sensor.state == OPEN) {
                        logWarn("heating", "Room " + room_name + " sensor " + sensor.name + " is " + sensor.state)
                        room_sensors_enabled = false
                    }
                }
            ]
        } catch(Throwable t) {
            // Nothing
        }

        if (room_heating_enabled) {
            if (room_sensors_enabled) {
                logWarn("heating", "Set room " + room_name + " -> ")
            } else {
                logWarn("heating", "Set room " + room_name + " -> sensors disabled")
            }
        } else {
            logWarn("heating", "Set room " + room_name + " -> disabled")
        }
    ]
end



// === RULE CONTROLS ==========================================

rule "Auto command"
when
	Item hz_temp_auto changed
then
	if (cfgHeatingEnable.state != ON || (cfgHeatingAutoEnable.state != ON && hz_temp_auto.state != cfgHeatingTempOff.state)) {
		logInfo("heating", "Auto disabled")
		return
	}

	// Check perisstance only if setting temp != OFF
	if (hz_temp_auto.state != cfgHeatingTempOff.state) {
		// Check that people are here
		if (cfgHeatingPersistanceEnable.state == ON) {
			if (presAll.state != ON) {
				// Nobody at home, skip auto set
				logInfo("heating", "Nobody at home, skip auto set")
				g_hz_all.sendCommand(cfgHeatingTempOff.state as Number)
				return
			}
		}
	}

	logInfo("heating", "Auto temp -> " + hz_temp_auto.state)
	// g_hz_auto.sendCommand(hz_temp_auto.state as Number)

    // Now we can apply new temp to members
    g_hz_auto.members.forEach [s |
        s.sendCommand(hz_temp_auto.state as Number)
    ]
end

// === HEATING SWITCHES =========================================

rule "Heating NS boost switch"
when
	Item hz_ns_boost changed
then
	if (ON != cfgHeatingEnable.state) {
		logInfo("heating", "Heating disabled")
		return
	}

	logInfo("heating", "Heating NS boost -> " + hz_ns_boost.state)

	if (ON == hz_ns_boost.state) {
		ns_boost_power_sw.sendCommand(ON)
		hz_ns_mode.sendCommand("BOOST")
	} else {
        ns_boost_power_sw.sendCommand(OFF)
		hz_ns_mode.sendCommand("MANUAL")
	}
end

rule "Heating presense switch"
when
	Item presAll changed
then
	if (ON != cfgHeatingEnable.state) {
		logInfo("heating", "Heating disabled")
		return
	}

	if (ON != cfgHeatingPersistanceEnable.state && ON == presAll.state) {
		logInfo("heating", "Return-heat is disabled")
		return
	}

	logInfo("heating", "Heating switched by presence to " + presAll.state)

	if (presAll.state == ON) {
		g_hz_all.sendCommand(hz_temp_auto.state as Number)
	} else {
		g_hz_all.sendCommand(cfgHeatingTempOff.state as Number)
	}
end

rule "Heating master switch"
when
	Item cfgHeatingEnable changed
then
	if (cfgHeatingEnable.state == ON) {
		g_hz_all.sendCommand(hz_temp_auto.state as Number)
	} else {
		g_hz_all.sendCommand(cfgHeatingTempOff.state as Number)
	}
end
