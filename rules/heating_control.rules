import org.openhab.core.model.script.ScriptServiceUtil

val Functions$Function2<String, Number, Boolean> set_room = [
    room_name,
    temperature |

    logInfo("heating", "set_room " + room_name + ": request " + temperature.toString)

    var thermostat_item_temp = room_name + "_hz"
    var thermostat_item_switch = room_name  + '_hz_enable'

    if (cfgHeatingEnable.state != ON) {
        logInfo("heating", "set_room: Heating disabled")
        sendCommand(thermostat_item_switch, OFF)
		return false
    }

    if (cfgHeatingAutoEnable.state != ON) {
		logInfo("heating", "set_room: Auto disabled")
		return false
	}

    var room_heating_enabled = true
    var room_sensors_enabled = true

    // Check that we have master-switch for this room
    try {
        val SwitchItem room_switch = ScriptServiceUtil.getItemRegistry?.getItem(room_name + "_heating_enabled") as SwitchItem
        // If we have
        // logWarn("heating", "Item room sw: " + room_switch)
        if (room_switch.state == OFF) {
            logWarn("heating", "set_room " + room_name + ": switch " + room_switch.name + " is " + room_switch.state)
            room_heating_enabled = false
        }
    } catch(Throwable t) {
        // Nothing
    }

    if (!room_heating_enabled) {
        logWarn("heating", "set_room " + room_name + ": disabled (switched off)")
        sendCommand(thermostat_item_temp, cfgHeatingTempOff.state.toString())
        return false
    }

    // Check that we have window-sensors for this room
    try {
        val GroupItem room_sensors = ScriptServiceUtil.getItemRegistry?.getItem(room_name + "_windows") as GroupItem
        room_sensors.members.forEach [sensor |
            if (room_sensors_enabled) {
                if (sensor.state == OFF || sensor.state == OPEN) {
                    logWarn("heating", "Room " + room_name + " sensor " + sensor.name + " is " + sensor.state)
                    room_sensors_enabled = false
                }
            }
        ]
    } catch(Throwable t) {
        // Nothing
    }

    if (!room_sensors_enabled) {
        logWarn("heating", "set_room " + room_name + ": disabled (sensors)")
        sendCommand(thermostat_item_temp, cfgHeatingTempOff.state.toString())
        return false
    }

    logInfo("heating", "set_room " + room_name + ": set now " + temperature.toString)
    sendCommand(thermostat_item_temp, temperature.toString())

    return true
]

// === MISC RULES ==========================================

rule "Heating safe switch"
when
	Time cron "0 00 01,02,03,04 ? * *"
then
	logWarn("heating", "Set safe off")

    if (cfgHeatingEnable.state == ON) {
        all_hz.sendCommand(cfgHeatingTempOff.state as Number)
    } else {
        all_hz_enable.sendCommand(OFF)
    }
end

// === TIME RULES ==========================================

rule "Heating NIGHT"
when
	Time cron "0 00 22 ? * *"
then
	logWarn("heating", "Set NIGHT")

    val temp = cfgHeatingTempNight.state as Number
    val temp_off = cfgHeatingTempNight.state as Number

    set_room.apply("ks", temp)
    set_room.apply("wz", temp)
    set_room.apply("ku", temp)
    set_room.apply("sz", temp_off)
    set_room.apply("kg", temp)
end

rule "Heating MORNING"
when
	Time cron "0 00 5 ? * *"
then
	logWarn("heating", "Set MORNING")

    val temp = cfgHeatingTempHeat.state as Number
    val temp_off = cfgHeatingTempNight.state as Number

    set_room.apply("ku", temp)
    set_room.apply("sz", temp)
    set_room.apply("kg", temp_off)
end

rule "Heating DAY"
when
	Time cron "0 00 10 ? * *"
then
	logWarn("heating", "Set DAY")

    val temp_off = cfgHeatingTempNight.state as Number

    set_room.apply("ku", temp_off)
    set_room.apply("sz", temp_off)
end

rule "Heating EVENING"
when
	Time cron "0 00 18 ? * *"
then
	logWarn("heating", "Set EVENING")

	val temp = cfgHeatingTempHeat.state as Number
    val temp_off = cfgHeatingTempNight.state as Number

    set_room.apply("ku", temp_off)
    set_room.apply("sz", temp_off)
    set_room.apply("kg", temp)
end

rule "Heating for study"
when
	Time cron "0 00 06 ? * WED,FRI"
then
	logWarn("heating", "Set study mode")

	val temp = cfgHeatingTempHeat.state as Number

    set_room.apply("kg", temp)
end

// This rule is fired if any window open/closed
// Will stop heating on open
rule "Windows state changed"
when
	Item g_all_contact received update or
	Item g_all_contact received command or
    Item g_all_contact changed or
    Member of g_all_contact changed
then
    if (cfgHeatingEnable.state != ON || (cfgHeatingAutoEnable.state != ON)) {
		logInfo("heating", "Windows: Auto disabled")
		return
	}
    logInfo("heating", "Windows state changed")
	all_windows.members.forEach [sensor_group |
        val room_name = transform("REGEX", "(.*)_windows", sensor_group.name.toString)
        var room_sensor_state = false
        var sensor_group_g = sensor_group as GroupItem

        // logInfo("heating", sensor_group_g.name.toString)
        // logInfo("heating", sensor_group_g.state.toString)

        // Enumerate all sensors in this room
        sensor_group_g.members.forEach [room_window_sensor |
            var room_sensor_item = room_window_sensor as ContactItem
            // Sensor is OPEN?
            if (room_sensor_item.state == OPEN) {
                // Sensor is member of 'windows_skip_off'? (Skip auto off)
                var sensor_groups = room_sensor_item.getGroupNames()
                // logInfo("heating", sensor_groups.toString)

                if (sensor_groups.contains("windows_skip_off")) {
                    logInfo("heating", "Windows: " + room_name + " sensor " + room_window_sensor.name + " is open, but skipped")
                } else {
                    logInfo("heating", "Windows: " + room_name + " sensor " + room_window_sensor.name + " is open")
                    room_sensor_state = true
                }
            }
        ]

        if (room_sensor_state) {
            // Stop heating
            logInfo("heating", "Windows: Room " + room_name + " window is open, stop heating")
            // Check that we have heating for this room
            try {
                val NumberItem room_hz = ScriptServiceUtil.getItemRegistry?.getItem(room_name + "_heating_thermostat") as NumberItem
                room_hz.sendCommand(cfgHeatingTempOff.state as Number)
            } catch(Throwable t) {
                // Nothing
                logInfo("heating", "Windows: Not found heating for room " + room_name)
            }
        }
    ]
end

// === HEATING SWITCHES =========================================

// rule "Heating NS boost switch"
// when
// 	Item ns_heating_boost changed
// then
// 	if (ON != cfgHeatingEnable.state) {
// 		logInfo("heating", "Heating disabled")
// 		return
// 	}

// 	logInfo("heating", "Heating NS boost -> " + ns_heating_boost.state)

// 	if (ON == ns_heating_boost.state) {
// 		ns_heating_boost_power_sw.sendCommand(ON)
// 		// ns_heating_mode.sendCommand("BOOST")
//         g_hz_ns.sendCommand(cfgHeatingTempHeat.state as Number)
// 	} else {
//         ns_heating_boost_power_sw.sendCommand(OFF)
// 		// ns_heating_mode.sendCommand("MANUAL")
//         g_hz_ns.sendCommand(cfgHeatingTempDay.state as Number)
// 	}
// end

rule "Heating presense switch"
when
	Item presAll changed
then
	if (ON != cfgHeatingEnable.state) {
		logInfo("heating", "Heating disabled")
		return
	}

	if (ON != cfgHeatingPersistanceEnable.state && ON == presAll.state) {
		logInfo("heating", "Return-heat is disabled")
		return
	}

	logInfo("heating", "Heating switched by presence to " + presAll.state)

	if (presAll.state == ON) {
		// all_hz.sendCommand(hz_temp_auto.state as Number)
	} else {
		all_hz.sendCommand(cfgHeatingTempOff.state as Number)
	}
end

rule "Heating master switch"
when
	Item cfgHeatingEnable changed
then
	if (cfgHeatingEnable.state == ON) {
		// all_hz.sendCommand(hz_temp_auto.state as Number)
        all_hz_enable.sendCommand(ON)
	} else {
		all_hz.sendCommand(cfgHeatingTempOff.state as Number)
        all_hz_enable.sendCommand(OFF)
	}
end
